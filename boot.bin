$ as -o boot.o boot.s 
$ ld -o boot.bin --oformat binary -e init boot.s 
$ ls -lh . 
  3 boot.bin 
784 boot.o 
152 boot.s

.code16 
.global init # makes our label "init" available to the outside 
init: # this is the beginning of our binary later. 
  jmp init # jump to "init" 
.fill 510-(.-init), 1, 0 # add zeroes to make it 510 bytes long

$ as -o boot.o boot.s 
$ ld -o boot.bin --oformat binary -e init boot.s 
$ ls -lh . 
 510 boot.bin 
1.3k boot.o 
 176 boot.s

 .code16 
.global init # makes our label "init" available to the outside 
init: # this is the beginning of our binary later. 
  jmp init # jump to "init" 
.fill 510-(.-init), 1, 0 # add zeroes to make it 510 bytes long 
.word 0xaa55 # magic bytes that tell BIOS that this is bootable

QEMU

.code16 
.global init # makes our label "init" available to the outside 
init: # this is the beginning of our binary later. 
  mov $0x0e41, %ax # sets AH to 0xe (function teletype) and al to 0x41 (ASCII "A") 
  int $0x10 # call the function in ah from interrupt 0x10 
  hlt # stops executing 
.fill 510-(.-init), 1, 0 # add zeroes to make it 510 bytes long 
.word 0xaa55 # magic bytes that tell BIOS that this is bootable

.code16 
.global init # makes our label "init" available to the outside 
init: # this is the beginning of our binary later. 
  mov $0x0e, %ah # sets AH to 0xe (function teletype) 
  mov $msg, %bx # sets BX to the address of the first byte of our message 
  mov (%bx), %al # sets AL to the first byte of our message 
  int $0x10 # call the function in ah from interrupt 0x10 
  hlt # stops executing 
msg: .asciz "Hello world!" # stores the string (plus a byte with value "0") and gives us access via $msg 
.fill 510-(.-init), 1, 0 # add zeroes to make it 510 bytes long 
.word 0xaa55 # magic bytes that tell BIOS that this is bootable

mov $msg, %bx
mov (%bx), %al

$ as -o boot.o boot.s 
$ ld -o boot.bin --oformat binary -e init -o boot.bin boot.o 
boot.o: In function `init': (.text+0x3): relocation truncated to fit: R_X86_64_16 against `.text'+a

$ as -o boot.o boot.s 
$ ld -o boot.bin --oformat binary -e init -Ttext 0x7c00 -o boot.bin boot.o

.code16 # use 16 bits 
.global init 
init: 
  mov $msg, %si # loads the address of msg into si 
  mov $0xe, %ah # loads 0xe (function number for int 0x10) into ah print_char: 
  lodsb # loads the byte from the address in si into al and increments si 
  cmp $0, %al # compares content in AL with zero 
  je done # if al == 0, go to "done" 
  int $0x10 # prints the character in al to screen 
  jmp print_char # repeat with next byte 
done: 
  hlt # stop execution 
msg: .asciz "Hello world!" 
.fill 510-(.-init), 1, 0 # add zeroes to make it 510 bytes long 
.word 0xaa55 # magic bytes that tell BIOS that this is bootable



